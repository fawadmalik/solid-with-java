# Decoupling Components with the Dependency Inversion Principle (DIP)

The Dependency Inversion Principle
Hello again. In this module, we'll see how to effectively decouple components by using the dependency inversion principle. In my opinion, this is the most important principle of object-oriented design because it enables us to create systems that are loosely coupled, easy to change, and maintain. We start by defining the dependency inversion principle. Then we'll write some code that respects this principle and see what it looks like. Then we'll discuss dependency injection, a popular technique in which a component does not have to bear the responsibility of creating its own dependencies. Then we'll talk about inversion of control. And after that, we'll have a demo in which we decouple components and improve testability by applying the dependency inversion principle. Let's start with a definition. The dependency inversion principle states that high-level modules should not depend on low-level modules. Both should depend on abstractions. Also, abstractions should not depend on details. Details should depend upon abstractions. This definition is a little bit abstract in nature. Before we fully understand it, we need to ask ourselves, What is a high-level module or a low-level module? What is an abstraction. So, let's answer these questions first, and then this definition will make a whole lot of sense. High-level modules are the part of our application that bring real value. They are the modules written to solve real problems and use cases. They are more abstract in nature and map to the business domain. Most of us call this business logic. Each time you hear the words business logic, we are referring to those high-level modules that provide the features of our application. High-level modules tell us what the software should do, not how it should do it, but what the software should do. By contrast, low-level modules are implementation details that are required to execute the business policies. Because high-level modules tend to be more abstract in nature, at some point in time, we will need some concrete features that help us to get our business implementation ready. They are the plumbing for the internals of a system. And they tell us how the software should do various tasks. So, high-level modules tell us what the software should do, and low-level modules tell us how the software should do various tasks. Here are a couple of examples for low-level modules--logging, data access, network communication, and IO. These are typical examples of low-level modules, and in reality, they tend to be very concrete. When we talk about logging, we'll talk about console logging or file logging. When we talk about data access, we'll talk about relational data access or NoSQL data access. For network communication, we'll talk about ports, protocols, and so on. The idea is that these modules tend to be very concrete in their nature. In a typical system, high-level modules work together with low-level modules to deliver the business value for our customers. In this example, we have payment and user management, which are all high-level modules of an HR framework. In order for them to work, they depend upon low-level modules such as networking, notification system, data access, and security. Notice that each of these low-level modules is very concrete. We tackle networking via GPRS. And when we talk about data access, we should have a relational system. And security is implemented via OAuth. Also, the notification system uses emails. Another key point here is that high-level and low-level modules are relative concepts. For example, the notification system is a low-level module for the payment module. However, the email service is a low-level module for the notification system. So in that context, the notification system is the high-level module, and the email service is the low-level module. We tend to think about the components in this way. They're not absolute terms. They're always relative to one another. An abstraction is something that is not concrete. It's something that we as developers cannot "new" up. In Java applications, we tend to model these abstractions using interfaces and abstract classes. We have now defined all the terms that make up the definition for the dependency inversion principle. So let's take a look at how this principle actually works. Traditionally, when we depend on details, our components tend to look like this. We have high-level components, which directly depend upon low-level components. Of course, this violates the dependency inversion principle because both should depend on abstractions. Let's introduce an abstraction here. Component A, which is a high-level component, no longer depends directly on component B. It depends upon an abstraction. And component B, which is low level, also depends upon that abstraction. We have the first part of the definition of the principal here. Also, the component B abstraction should not depend on other details. I also like this schematic because it illustrates the inversion word in the dependency inversion principle name. When we depend on details, the dependency flows from the high-level component to the low-level component. When we depend on abstractions, that dependency flow is inverted as shown with the arrows of this schema.

### Writing Code That Respects the Dependency Inversion Principle
Now that we know what the dependency inversion principle is, let's see how we can write code that respects it. Let's start with this class SqlProductRepo. This class has a single method getById, which receives the productId as a string and returns the Product if it finds it in a SQL database. This is a perfect example of a low-level module. It's a concrete data access class that uses SQL to return products from the database. Then we have another class called PaymentProcessor. PaymentProcessor exposes a pay method, which also receives a productId. Then it finds that project via the SqlProductRepo and processes the payment. In this context, PaymentProcessor is the high-level module and SqlProductRepo is the low-level module. However, let's look at the downside of implementing code this way because clearly the PaymentProcessor has a direct dependency with the SqlProductRepo. We can see it here in the pay method where we actually instantiate this repo. We are newing up a new instance of the SqlProductRepo class. This clearly violates the dependency inversion principle. Now let's see how we can make this code better. The first thing that we need to do is to extract the interface for the low-level module, in our case the SqlProductRepo. We will create an interface called ProductRepo, which has the getById method. Just by looking at it, we don't know where this product is going to come from. It could come from any data source. Then the SqlProductRepo class implements the product repository (ProductRepo) and overrides the getById method with concrete details for fetching a product from a SQL database. However, we can have more concrete classes that implement this product. We can have a MongoProductRepo or an ExcelProductRepo. The ProductRepo interface is unaware of the implementation details. The PaymentProcessor now can be modified to look like this. We still have the pay method, and we get an instance of the ProductRepo interface with this factory. Then we get the product by ID and process the payment. Now our method does not directly depend on a concrete implementation of the ProductRepo. We depend on the abstraction. We depend upon the ProductRepo interface. The factory here gives us a concrete instance. It can be a SqlProductRepo, a MongoProductRepo, or an ExcelProductRepo. It doesn't really matter, and this high-level component doesn't care what instance is served at runtime as long as it respects the contract. The factory, of course, is pretty simple. It has a static method that returns an instance of a ProductRepo abstraction, in this case the SqlProductRepo. But we can modify this factory and make it more smart. For example, we can modify the create method by passing in a type argument. And now we can return varies instances of ProductRepo based on that type. For example, if the type equals Mongo, we can return a MongoProductRepo. Else, we can return a SqlProductRepo. The consuming code will not care what particular instance is returned. Ultimately after applying the dependency inversion principle, our components look like this. We have the PaymentProcessor, which is the high-level module. At the bottom we have the SqlProductRepo class, which is the low-level module. And in between we have the ProductRepo interface. Both modules depend on the ProductRepo abstraction, and the abstraction itself does not depend on any details. So we have applied the dependency inversion principle to our particular case. More importantly, we have eliminated the coupling between PaymentProcessor and the SQL implementation of the ProductRepo.

### Dependency Injection (DI)
Let's take a couple of minutes to discuss dependency injection. Dependency injection is very used in conjunction with the dependency inversion principle. However, they are not the same thing. Let's look at how we left the PaymentProcessor class. We have the pay method, and the ProductRepo abstraction is now produced by the ProductRepoFactory. Although we have eliminated the coupling with the concrete SqlProductRepo class, we still have a small coupling with the ProductRepoFactory. We have more flexibility after applying the dependency inversion principle, but I'm pretty sure we can do a better design than this. Let's come up with a better solution. This is where our dependency injection comes in. Dependency injection is a technique that allows the creation of dependent objects outside of a class and provides those objects to a class. We have various methods of doing this. One of them is by using public setters to set those dependencies. However, this is not a good approach because it might leave objects in an uninitialized state. A better approach is to declare all the dependencies in the component's constructor like we are doing here. The PaymentProcessor class now has a constructor that accepts a ProductRepo abstraction as a parameter. The ProductsRepo then becomes a private field of the PaymentProcessor class. We can then use the repository to get a product by ID and process the payment. The PaymentProcessor class is no longer responsible for creating its own dependencies. It is the caller's job to provide those dependencies. Here we can imagine we have the main method. We create a new instance of a ProductRepo by using the factory, and then we create a PaymentProcessor instance bypassing that repo instance to the PaymentProcessor constructor. We can then call the pay method. This is how we use dependency injection in order to decouple our components even more. Let's look at a more complex example. We have five classes over here. Classes A and B have no dependencies whatsoever. Class C depends on class A. Class D has a dependency on class B. And class E has a dependency on both classes C and D. If you want to call a method on class E, we also need to create all the dependencies that it needs. We need to take care of all of that dependency handling. We need to create concrete instances of those classes in a particular order. We have to create classes A and B first because they have no dependencies, then classes C and D. And at the end, you can create class E and call a method on it. This is a pretty simple example with just five classes. But our real projects have hundreds if not thousands of classes that can be instantiated. Although dependency injection is a pretty cool technique, doing it manually is clearly not the way to go forward. We cannot tackle this much complexity by hand. Also, think about the lifecycle of these objects. Maybe we want A and B to be singletons and C, D, and E to be objects that are created on every request. How do we do that manually? Well, even more logic has to come into the creation of these objects. Clearly, we need something else. Luckily for us, there's another piece to this puzzle, and that piece is called the inversion of control principle.

Inversion of Control (IoC)
Inversion of control can help us create large systems by taking away the responsibility of creating objects. Inversion of control is a design principle in which the control of object creation, configuration, and lifecycle is passed to a container or framework. The control of creating and managing objects is inversed from the programmer to this container. We don't have to "new" up objects anymore. Something else creates them for us, and that something else is usually called an IoC container or DI container. The control of object creation is inverted. It's not the programmer but the container that controls those objects. It makes sense to use it for some objects in an application like services, data access, or controllers. However, for entities, data transfer objects, or value objects, it doesn't make sense to use an IoC container. We can simply "new" up those objects, and it's perfectly okay from an architectural point of view. There are many benefits in using an IoC container for your system. First of all, it makes it easy to switch between different implementations of a particular class at runtime. Then, it increases the programs modularity. And, last but not least, it manages the lifecycle of objects and their configuration. For example, you can decide that some objects should be singletons while other objects should be created per every web request. I think that Spring is the most popular Java framework out there. At the core of the Spring framework is the Spring IoC container. You've probably heard about Spring beans. They are objects used by your application that are managed by the Spring IoC container. They are created with the configuration that you supply for that container. There are many ways to configure an IoC container in Spring. XML is one example. Creating configuration classes is another. Or simply by annotating classes with special annotations like atService, atComponent, atRepository, and so on and so forth. Let's look at a simple Spring bean definition example. We'll take the Configuration class approach. We have this normal class called DependencyConfig. We annotated with @Configuration to make it visible to the Spring IoC container. Like I said before, beans are just normal classes that are managed by the Spring IoC container. Classes A and B are classes with no dependencies. We declare them here with a @Bean annotation. Class C has dependencies on class A and class B. We are using the @Bean annotation, and we are passing the A and B arguments to the constructor of type C. Notice that we are not creating new types for A and B. We let the IoC container handle the creation of A and B for us. Then class C looks something like this. It has two private fields, A and B, and a constructor. When we need an instance of this class, the Spring IoC container will look at the constructor. It then extracts the dependencies that class needs, in our case A and B. Because we declared A and B as beans in the configuration class, the Spring IoC container can inject them over here, and thus it can create an instance of class C. This whole process of creating, handling dependencies, and creating objects has been taken away from the programmer. The Spring IoC container manages it very well. Let's finish this lecture with a small recap. A dependency inversion principle, dependency injection, and inversion of control work very well together and are the most effective way to eliminate coupling. They are not, however, the same thing, and sometimes they will get confused. The dependency inversion principle tells us that high-level modules should not depend on lower-level modules. They should both depend upon abstractions. Dependency injection is a technique in which a component is not responsible for the creation of its own dependencies. Rather, it can declare those dependencies in the constructor, and in the calling code, a programmer or another framework can inject them. Manually handling and creating dependencies is not scalable, especially for large applications. This is where an inversion of control container comes in. It can handle the creation and lifecycle of all the objects in our application.

### Demo: Refactoring Code with the Dependency Inversion Principle
It's time to write some code and apply what we have learned so far. In this demo, we'll apply the dependency inversion principle. In the process, we'll decouple a high-level component from a low-level component using abstractions, and we'll also improve the testability of our application. In order to understand the dependency inversion principle, we are going to look at the payment processing feature of the Globomantics HR framework. This system is to retrieve all the employees and pay their incomes. Upon completion, the total paid sum must be calculated and compared with the finance department. Also, each employee should receive an email after the income payment was sent successfully. To implement this feature, we have created the PaymentProcessor class, which is located in the payment package. The PaymentProcessor is the class responsible for paying the incomes of all employees. It has a sendPayments method, which gets all the employees from the EmployeeFileRepository. Then for each employee, it calculates the payment and sends a notification via email. This component is highly coupled with the EmployeeFileRepository and the email service. Right here in the PaymentProcessor constructor, we can see that this high-level component is actually creating its own dependencies. We also have a dependency on EmailSender. We don't new up a new instance of EmailSender, but static method calls are also a sign of coupling. We can say without a doubt that the PaymentProcessor class is very aware of its implementation details. Let's take a look at the EmployeeFileRepository. We can find it in the persistence package. The method that we are interested in in the EmployeeFileRepository is the findAll method. This method opens the employees.csv file, which is located on the resources folder, and then it reads each line and creates an employee from each CSV line in there. Now let's take a look at the EmailSender class located under the notifications package. The EmailSender has one public static void method called notify, which receives an employee. It creates all the properties of the email server. Then we construct the MimeMessage, and then we send that message and print out something to the console. This class will actually send emails to a test server configured via Mailtrap. The PayEmployeesMain program is the place where we instantiate the PaymentProcessor and then call the sendPayments method. This program works, but our application is very, very coupled. Going back to the PaymentProcessor, you have to ask yourself, What's going to happen if a particular client doesn't want to read employees out of a CSV file? What is going to happen, for example, if he wants to read employees from a SQL database? What happens if a particular client doesn't want his employees to receive emails, but text messages or slide notifications? The way we have written our code, it's impossible to reconfigure this behavior at runtime. PaymentProcessor initializes its own EmployeeRepository and depends directly on the EmailSender. So the only way we could achieve this is to come here and modify this class. So we're not only violating the dependency inversion principle, we're also violating the open closed principle. Testing is also affected with this high level of coupling. Let's take a look at the test for a PaymentProcessor class. We want to test the PaymentProcessor, so we put the test under test, java, hr.payment. This test class has a single test method. SendPayments should pay only employee salaries. Here we create an instance of the PaymentProcessor. Then we execute the sendPayments method. Then we assert that the result is equal to $5, 440. We computed the result by looking at the employee's CSV file. This CSV file contains the names, incomes, and number of hours worked per week for each employee. We calculated all the incomes, and the value was $5, 440. That's the value that we used in our test. Let's go ahead and run this test. The test was executed with success. However, I would argue that this is not a good test. What do you think is going to happen if we start to modify the incomes of some employees or if we delete an employee? Obviously, the total salaries that are going to be paid is not going to be equal to $5, 440. So our test is going to fail. Also, what is going to happen if you're running this test in a build environment where we don't have access to the internet. Well, the email sender is not going to work. It's going to throw an exception. So our test is also flaky. If we have an internet connection and a correct main server configured, it's going to pass. Otherwise, it's going to fail. All that we wanted was to test the PaymentProcessor class. We're interested to see if the total amount of salaries paid is equal to the sum of salaries of all employees. We don't care how those employees are retrieved. We don't care how those employees are notified. All these problems are caused by coupling. We can't evolve the PaymentProcessor, and we cannot write stable unit tests for it. Let's fix our design by applying the dependency inversion principle. Right now our high-level component PaymentProcessor depends on low-level modules, such as the EmployeeFileRepository and the EmailSender. We need to break these dependencies. We need to make them both depend upon abstractions. I went ahead and created two new interfaces, EmployeeRepository and EmployeeNotifier. EmployeeRepository is declaring two methods, findAll and save. EmployeeNotifier defines the notify method. Let's look at the concrete classes and see how they have changed. EmployeeFileRepository now implements the EmployeeRepository interface. No additional change has been done to this class. The interface still provides the findAll and save methods. The EmailSender class now implements the EmployeeNotifier interface that we just created. The notify method is no longer static. That is the only change we did to this class. The rest of the implementation remains the same. Right now developer components depend upon abstractions. Let's look at the high-level component, the PaymentProcessor. The PaymentProcessor now has two dependencies on abstractions, EmployeeRepository and EmployeeNotifier, both interfaces. We also used the dependency injection technique in the PaymentProcessor constructor. This constructor now expects two types, an EmployeeRepository and an EmployeeNotifier, to be passed by the calling component. An implementation with sendPayments method remained almost identical. Although the code doesn't seem to have changed a lot, the implications are huge. PaymentProcessor can now be modified at runtime. We can pass various instances of EmployeeRepository. You can pass in a FileRepository, a SqlRepository. We can also pass in various instances of an EmployeeNotifier. We can pass the EmailSender, or we can pass a slide notifier or a text notifier. The code is no longer coupled. The high-level components and low-level modules both depend upon abstractions. The PayEmployeesMain method changed a little bit. Because you are using dependency injection and this is the calling component, we need to create those dependencies here. So we are creating instances for EmployeeRepository and EmployeeNotifier. We are using those dependencies to create the PaymentProcessor, and then we execute the sendPayments method. Testability has improved. Because the PaymentProcessor depends on abstractions, we can mock those dependencies and pass them in the constructor, thus bypassing the need to read employees from a CSV file and to send actual emails. We are doing this in this beforeAll method. Generally, you need to call this method before executing each test in this class. Here we define a fixed list of employees for testing purposes. We no longer read them from the CSV file. Then we create an employeeRepositoryMock. A mock is a fake object for which we can provide behavior in the test phase. When we call the findAll method on this employeeRepositoryMock, we return the testEmployees. We also mock the email notifier because we don't want to send the real emails in this test. The test method changed a little bit. We are creating a new PaymentProcessor passing in the two mocks that we just created. Then we call the sendPayments method, and we assert that the total payments is equal to $1, 700. This is actually the sum of all the incomes for the employees defined over here. We now have control over the employees. Because you don't read them from a file, this test is going to be stable. Changes in production will not affect our test. Also, because you're not using a real email service, it doesn't matter where we'll run this test. This test will always execute. So let's go ahead and run it. The test worked as expected. Also notice the speed of this test. It now executed in 37 ms, way faster than the previous one. This is how we can apply the dependency inversion principle and the dependency injection technique to break coupling between high-level modules and low-level modules. It is always better to depend upon abstractions. Code becomes less coupled, testability increases, and your overall design is more flexible and modular.

### Summary
In this module, we learned that classes should always depend on abstractions and not on implementation details. The dependency inversion principle, dependency injection, and inversion of control work hand in hand to eliminate coupling and make your applications less brittle. Testability can be greatly improved by using the dependency inversion principle and the dependency injection technique. If you make all your high-level components depend on abstractions, declare your dependencies in the constructor, and use a good mocking framework, then you have all the chances to create robust, solid, and predictable unit tests. If you're developing your applications using Spring, then you have to take advantage of the powerful capabilities of the Spring IoC container. Large enterprise applications cannot be written, in my opinion, without inversion of control, and the Spring IoC container is pretty, pretty powerful. There is a pretty cool catchphrase from Steve Smith that I really like, "New is glue. " When your high-level components create their own dependencies or new up their own dependencies, then code coupling starts creeping into your application. Code coupling brings technical debt, so your system is going to suffer from rigidity and fragility. It's much better to make high-level components depend on abstractions and leave the creation of objects to a completely different framework. A dependency inversion principle, dependency injection, and IoC are the most effective ways to eliminate code coupling and keep systems easy to maintain and evolve.

# Course Summary and Key Takeaways
Congratulations for reaching the end of this course. I want to take a couple of minutes to recap some key takeaways. As you saw, technical debt is the silent killer of software projects. Coupling is the main reason of technical debt. If you have high levels of code fragility and code rigidity, it's probably caused by high coupling. SOLID principles are a great way to tackle coupling and promote designs that can evolve and grow over time. The SOLID principles of object-oriented design are the foundation of clean system architectures, but they're not the only tool that you can use. I like to call this the pyramid of clean code. The SOLID principles are the foundation. On top of that, you can find design patterns. Then you have test-driven development. And on top we have continuous refactoring. Remember that you always have to pay your technical debt. Otherwise, it will grow out of control, and it will bring your projects to a halt. These techniques can be used individually, but they work best when you apply them together. In fact, if you're new to design patterns and test-driven development, here are a couple of great courses on Pluralsight that can help you. The first one is the Design Patterns in Java series by Bryan Hansen. The second one is Test Driven Development Practices in Java by Mike Nolan. These are great courses that will help you build your arsenal of clean code techniques. In the end, I would like to tell you that you can find all the source code that you have seen throughout these modules at GitHub by following this link. I really hope that you had fun watching this course. You should now be able to use the SOLID principles in your own projects to write solid, clean code. Until next time, have a great day and write amazing code.
