# Problems That Appear When SOLID Principles Are Not Used
There are many problems that can appear when SOLID principles are not used. Let's look at a couple of examples. Let's assume we have this application with the following submodules. We have a new change request. We need to add a new payment method. So we, as developers, go ahead and implement the change. We go to the Payment module, we make the change, we then deploy our application. And after deployment, we notice that we have bugs in other subsystems. This is called code fragility. It's a term coined by Robert C. Martin, or uncle Bob. Code fragility is the tendency of software to break in many places every time you write a change to it. Let's look at the different example. We have the same application and a new change request. We need to update the reports with new information. So, again, we go to the reporting module and we start to implement the change. But, unfortunately, we cannot finish it because in order to modify the reporting module, we also have to modify other parts of the system. This is another symptom of code that is not robust, and it is called code rigidity. Rigidity is the tendency for software to be difficult to change even in simple ways. Every time we have to make a modification, a cascade of other changes needs to be done before that. Code fragility and rigidity are symptoms of high technical debt. If you encounter this in your own projects, then you most likely did not use SOLID principles when designing and architecting your application.

## Technical Debt
Technical debt is the silent killer of all software projects. Therefore, it's really important to know what it is and how we can protect ourselves against it. Although it's quite a fuzzy term, technical debt is just a cost. It's the cost of prioritizing fast delivery over code quality for long periods of time. Now think about and imagine you're working on a project. For each change or bug that you need to implement, you have a choice. You can either go for fast delivery, which is easier, it's the easiest thing that you can do to implement a change or fix the bug. It's very fast so you don't lose any time on it. It's the fastest time to delivery. But you will gain poorly written code. On the other hand, if you choose code quality, you have to spend a little bit more time to understand all the implications, try better unit tests to make your components less coupled, so you lose time. You also add a bit of complexity to your code. But, you end up with maintainable code that is easier to change and evolve over time. So this is the choice that you always have to make when implementing changes to your application. It's not realistic to think that you'll always be able to choose code quality. Sometimes we really need to get the change into production really fast, so it's okay to choose fast delivery sometimes. But if you always choose fast delivery, thus, you always sacrifice code quality, you'll end up in a point where your project can no longer evolve, and that's a really dangerous place to be in. I also think that it's easy to understand technical debt if you look at the following charts. Let's take this simple example. We have an application that we deployed, and now we have to maintain it over a couple of years. Obviously, customers will want changes during the maintenance phase. And, obviously, those changes are going to have a financial cost associated with them. In an ideal world, that cost should be kept to a minimum. That cost should be manageable at all times. However, in projects that have high technical debt, the cost of change tends to grow over time. And it grows and grows so much until it's no longer manageable. And in this chart, we can clearly see the cost of technical debt. There is a second type of cost that comes with high levels of technical debt, and that is customer responsiveness. At the beginning of a project, we are able to respond to our customers' needs really, really fast, and that keeps our customers very happy. However, in projects that have a high level of technical debt, our response time tends to grow larger and larger over the years. Again, we have a technical debt cost that is clearly seen in this chart. We need to take this cost into consideration because after we pass a specific point, that project is automatically a failure. Here are some facts about technical debt. First of all, no matter how good your team is, technical debt will accumulate over time. There is nothing you can do about that. If left uncontrolled, technical debt will slowly but surely kill your project. The only thing that you can do is to try to keep it under control. And here's how we can do that. You write some code for one of the sprints, and then you take some time to pay your technical debt. You apply SOLID principles, you apply design patterns, you refactor, you decouple your components, you write more unit tests, you do everything that you can to make your code less coupled and more maintainable. And then you write some more code, and then you take some time to pay the newly acquired technical debt. And this cycle will go on forever. That's how you keep technical debt under control.

The SOLID Principles
We looked at the problems of legacy systems. We understood the costs of technical debt. And now it's time to focus our attention towards the SOLID principles. SOLID is an acronym for five software development principles that help us to keep technical debt under control. The five SOLID principles are the single responsibility principle, the open closed principle, the Liskov substitution principle, the interface segregation principle, and the dependency inversion principle. The first letter of each of these principles firms up the SOLID acronym. There are plenty of practical benefits for writing SOLID code. First of all, when you write SOLID code, it is easier to understand and reason about. Changes are faster and have a minimal risk level. The code is highly maintainable over long periods of time. And it is also cost-effective. SOLID in my opinion is the foundation for clean code. But there are other ways to take things to a different level. Constant re-factoring, design patterns, and unit testing are great ways to keep your application easier to change and maintain over time.

Introducing the Sample Application
Understanding SOLID principles in theory is one thing, but knowing how and when to apply them in real applications is a completely different story. That's why I want to take a moment to discuss the sample application that we'll use throughout the rest of this course. We are going to work on a popular HR framework built by Globomantics. It is a framework that is highly appreciated by its customers because it offers features like employee management, tax calculations, pay slip generation, and reporting. I wanted to choose a domain which is really familiar but, at the same time, offers us enough opportunities to apply SOLID principles. Also, you'll have access to other source code that will be used throughout the rest of this course. Like I said, we are going to work on an HR framework. And our entrypoint to test and execute this framework is going to be a console-based application. Because we won't have any UI dependencies, we are really free to focus on what's important, and that is the business logic and how to correctly and efficiently use the SOLID principles. In this module, we saw that it's not enough to write code that works. The most successful projects are the ones that have a very large production lifespan. They're the ones where bug fixes are fast. They're the ones where changes are easy to do and don't cost a ton of money. We saw that technical debt can kill our project if left uncontrolled, and we also learned that by constant refactoring, we can pay it off and, thus, keep it under control. And last but not least, we learned about the five SOLID principles and how important they are for clean applications. They are the foundation of clean code. And in the next modules, we are going to take each one and look at it in detail.

Understanding the Single Responsibility Principle (SRP)
The Single Responsibility Principle
We'll take a deeper look at the single responsibility principle. You'll learn what the single responsibility principle is. Then you'll be able to efficiently identify multiple reasons to change in your own codebase. You'll understand the danger of having multiple responsibilities in our methods or classes. And then we'll see a demo in which we'll refactor some legacy code and make it adhere to the single responsibility principle. The single responsibility principle has a pretty straightforward definition. Every function, class, or module should have one and only one reason to change. This definition seems pretty simple. However, it might be a little bit abstract. For example, what is a reason to change? Well, in this context, a reason to change is a synonym for responsibility. We set up a class which has a single responsibility, also has a single reason to change. So we can use these terms interchangeably. Let's take a look at some responsibilities that you've probably seen in your own applications. Business logic is one responsibility. The user interface is another. Persistence, logging are also pretty popular responsibilities. However, things like orchestration are also reasons to change. When you have a component that coordinates other components in order to achieve a particular result, that orchestration is a responsibility in itself. And also people are actors of change. And we'll see an example of this later on. One important habit that you need to develop as a software developer is the ability to identify the reasons to change that your components have and then to be able to reduce them to a single one. Now that we know what the single responsibility principle is, let's see why we should use it in our code. There are many benefits of using the single responsibility principle. First of all, it makes code easier to understand, fix, and maintain. We spend almost 90% of our time as software developers reading code, so it's pretty important to be able to understand it and reason about it very fast. And the SRP has a huge impact on readability. Then code that respects the single responsibility principle creates classes that are less coupled and more resilient to change. When we are using the single responsibility principle, we keep fragility and rigidity to very minimal levels. And, last but not least, we gain a more testable design, which is great from a quality point of view.

Identifying Multiple Reasons to Change
I'm going to show you a couple of tricks that will help you identify multiple reasons to change in your own classes and methods. And we'll do that by looking at a couple of examples. If statements are a clear sign that the method has multiple reasons to change. We have one reason to change on the if branch and a different reason to change on the else branch. Clearly, this piece of code violates SRP. What we could do here based on the complexity of the logic is that we could extract the logic for the if branch to a separate method or class and the logic for the else branch to a different method or class. The same goes for switch statements. Each case represents one responsibility. Again, we can extract them to different methods or classes and make this piece of code more easy to read, maintain, and understand. We should also pay attention to monster methods. We can identify them quickly because they have a large number of lines of code, and also they kind of mix the levels of abstraction within the implementation. For example, this method is called getIncome. So by reading the method name, we would expect this method to return an employee income. But when we look at this method, we see that it does a whole lot of things. Indeed, it gets the income from the employeeRepository. But then it sends that income to the StateAuthority via an API. It generates a pay slip. It converts it to JSON. And then he uses that JSON and sends it via email. Obviously, this method does not do one thing. It has many responsibilities, many reasons to change, and it's very, very fragile. Also notice the many dependencies that this method has. In order to do its job, it needs to know about the StateAuthorityApi, the Payslip, about JSON format, about the EmailService. This large number of dependencies is also a clear indicator that a method or a component does more than one thing. So, each time we see a monster method, we need to identify the responsibilities and then split it into multiple methods or even classes that are more manageable and that do just one thing. We saw a couple of methods that have many reasons to change and that violate the single responsibility principle. But classes can also do that. Let's take a look at God classes. Do you have projects where you keep helper methods, classes called Utils, helpers, shared, or something like this? Well, those are classes that clearly do more than they should. A typical Utils class will look like this. We have methods to save objects to a database. We have methods for serialization. We have logging in here. We have some friendly date helpers. And each time we write a piece of code that needs a place to live but it's not important enough to have its own class, we would probably put it in one of these classes. Please don't fall into this trap. Instead, prefer having specialized classes that handle pretty clear use cases. For example, you can have a utility class that just handles dates. You can give it a very meaningful name. Then you can have classes that deal only with serialization, classes that deal only with logging, classes that deal only with persistence. Don't put everything in a single class just because it's easier or because others have done it. People are also actors of change in software applications. This method, for example, generates a report that is used by both HR and management. The report is pretty similar to both parties. But at some point in time, HR will want a specific set of features and management will want a different set of features. Because of those needs, it's far better to separate the report and make a specific report for HR and a different one for management. This way both reports will have a single reason for change. This is a more subtle case of violating the single responsibility principle. Knowing when people are responsible for a piece of code depends entirely up to you and your expertise of the business domain. But it's worth knowing that the single responsibility principle is not all about code. It's also all about the actors who use your application. Finally, let's take a look at a piece of code that has a single responsibility. Look at this class. The name is very explicit. This class is called ConsoleLogger, a very explicit name. It basically tells you that its purpose is to log information to the console. And this purpose is reinforced when we look at the two methods, logInfo and logError. Of course this is a very simple and conceived example, but this is the feeling that you should have when you're reading a component that has a well-defined purpose. The name should be explicit, the functions and features should be in line with that purpose, and everything should be very, very focused. This is a good example of a class that respects the single responsibility principle.

The Danger of Multiple Responsibilities
I want to take a couple of minutes and discuss the dangers of writing code that has multiple responsibilities. First of all, that code is more difficult to read and reason about. Remember that we spend 90% of our time reading and understanding code. And we should make this process as easy as possible. Also, code that has many responsibilities has a poor quality because testing is far more difficult. Side effects are also a symptom of not using the single responsibility principle. Side effects are basically lies. When a function declares it does a particular thing but also does other things internally, side effects happen. And they are dangerous because most of the time they are hidden if you have to dig in the internals of an implementation to spot them. But the most dangerous symptom of not using the single responsibility principle is usually high coupling. Coupling is the level of interdependency between various software components. Components that have many reasons to change are usually tightly coupled. Coupling with concrete components is especially dangerous because it exposes you to the internal implementation of a particular class. Let's take this example. We have a getIncome method that receives an employee and, in return, that employee's income. In order to achieve this function, this class has a dependency on the repository implementation (RepositoryImpl), a concrete class. We also declare this repository internally and we construct it here. But what happens, for example, when the RepositoryImpl constructor changes? Well, of course, this piece of code will break. This introduces fragility and rigidity in our system. A better solution would have been to create an abstraction for the RepositoryImpl and pass it in as a parameter. In this scenario, the getIncome method is no longer aware of the internals of the Repository class and can do its job to get the income for a particular employee. We'll talk more about this technique when we discuss the dependency inversion principle. The key takeaway here is that if Module A knows too much about Module B, changes to the internals of Module B may break functionality in Module A. Like I said, this would introduce technical debt. Therefore, you should always pay attention to the dependencies of your particular components and try to extract them and abstract them as much as possible.

Demo: Applying the Single Responsibility Principle
You should now have a good understanding of the single responsibility principle. But the best way to learn it is by practice. In this demo, we will refactor a component that has many reasons to change. You'll use what you've learned so far and identify the responsibilities of that component. Then you'll extract them out by applying the single responsibility principle. The Employee class is at the heart of the Globomantics HR framework, and it models an employee from a business perspective. We can see common properties like firstName, lastName, monthlyIncome, and nbHoursPerWeek. But we also have this save method over here. Take a moment to look at this method and try to spot the many responsibilities that it has. First of all, we have a serialization of the employee in order to write it to the file system. That's one responsibility. Then we have a responsibility that deals with file access. We have logging as the third responsibility, and the overall coordination of these steps, including the exception handling, as another one. Also notice that the save method deals with persistence, but the Employee class is a business entity. Therefore, the save method should not even be in this class. We should probably move it to a separate component that handles persistence. So let's go ahead and refactor this method piece by piece. Let's start by moving the save method out of the Employee class. It turns out that you already have a component that deals with persistence, and that is the EmployeeRepository. So I'm going to go ahead and paste it as is in the EmployeeRepository class. Then we need to fix it by modifying things that don't compile by using the getters from the employee, and I'm going to remove the static modifier. We have now moved the save method out of the Employee, which makes the Employee class clean and adherent to the single responsibility principle. However, this method still has multiple responsibilities. So let's go ahead and extract them piece by piece. I want to move the serialization logic out of the save method. So I'm going to copy/paste it, and I'm going to create a new class that will deal specifically with employee serialization. I'm going to call it EmployeeFileSerializer. Notice that the names I'm giving are very explicit, and that will help you keep your classes short and focused. I'm going to create this class, and then I'm going to implement the save method. Now that we go back to the Employee, I also want to extract the logging out of this method. I'm going to go ahead, and I'm going to create a new class. I'm going to call it ConsoleLogger, again, a very explicit name, and I'm going to move logging in here. Now we can come back to the EmployeeRepository and change the implementation. For that, I need a dependency on the newly created employee serializer, and I'm going to add it here. Notice that I'm injecting this dependency in the constructor so that the EmployeeRepository does not have to concern itself with constructing a concrete instance of the EmployeeFileSerializer. Then I'm going to grab my serialized string by using the newly created serializer. I'm going to remove this whole implementation, and, of course, I'm going to make the necessary adjustments for this code to work. I'm going to arrange it nice and easy, and we can already see that the save method has grown shorter. We have passed the serialization responsibility to that employee serializer. Now we also have logging and orchestration. It's not a good idea to keep exception handling and logging in the save method. I want to move it out and let the caller handle it. So I'm going to completely remove the logging and the coordination out of this method. In the end, our method should look just like this. The save method is only concerned with saving that employee to the file system. Now that our Employee respects the single responsibility principle, let's go to the caller and make the necessary modifications. In our case, the caller is the main method that saves all the employees to the file system, and we need to make it work again. We notice that we can no longer construct the EmployeeRepository. That's because the constructor also needs an EmployeeFileSerializer. I'm going to go ahead, create the FileSerializer, and inject it in the EmployeeRepository. Now that we have a repository, we also need to change the call to the save method, which is no longer happening on the Employee class because we have extracted it to the repository. So we will replace this line with repository.save, and we are going to pass in the employee. And now we have to implement the exception handling logic and the logging in here because this is the caller. I'm going to surround this block with a try/catch. I'm going to give this exception a meaningful name. In case this fails, I'm going to use the logger class and log this exception. I'm going to use our newly created logger to write this exception to the console. For that, I need to instantiate our ConsoleLogger and use it to print that exception. ConsoleLogger.writeError, and I'm going to pass in a message, and I'm also going to pass in the exception. And if everything works okay, we still need to do this logging. So I'm going to use the consoleLogger and write a message to let us know that the employee has been successfully saved. I'm going to run this application just to make sure that everything still works. We have saved four employees. And if we look here, we can see the files where they have been written. Our job here is done. We have successfully refactored the employee save method by continuously applying the single responsibility principle and breaking functionality in specific components where needed. This is a typical process of how we can refactor Code to adhere to the single responsibility principle.

Summary
In this module, we took an in-depth look at the single responsibility principle. You saw how to correctly identify reasons of change in classes and methods. You learned that if statements, switch statements, God classes, and monster methods are all clear indications that a particular piece of code has many reasons to change and that you should do your best to refactor it. You then learned about the link between high coupling and code fragility. Code that has many reasons to change also tends to have many dependencies, which make it very brittle. And, finally, you learned how to refactor responsibilities out to specialized components in the demo. In most cases, this is a three-step approach, identifying the reasons to change, extracting them to different components which are specialized, and then re-factoring your code so that it compiles and works as expected. To quote one of my favorite books, The Pragmatic Programmer, "We always want to design components that are self-contained, independent, and with a single and well-defined purpose. " That's the essence of the single responsibility principle.
