# Applying Liskov Substitution Principle (LSP)

### The Liskov Substitution Principle
In this module, you'll learn to apply the Liskov substitution principle, the third one in the SOLID acronym. We start by defining the Liskov substitution principle and why it is so useful to create correct type hierarchies. Then we'll look at a couple of examples where this principle is violated. After that, we will learn how to fix incorrect relationships between types. And at the end, we'll have a demo in which we'll refactor a class to respect the Liskov substitution principle. This principle has many definitions. The first one is a little bit more abstract but very accurate. If S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without modifying the functionality or the correctness of the program. It's a pretty accurate definition although a little bit abstract, especially for beginners. That's why I prefer the second definition. Any object of a type must be substitutable by objects of a derived type without altering the correctness of that program. And I want to highlight the word substitutable. The Liskov substitution principle is all about relationships between types. As humans, we have a tendency to think about relationships as "is a. " We say that a square is a kind of rectangle or an ostrich is bird. However, in object-oriented terms, this "is a" relationship is not really helpful and can even make us create incorrect hierarchies of classes. Instead, we should ask ourselves if a particular type is substitutable by another type. For example, is the class rectangle fully substitutable by the class square? Or is the class ostrich fully substitutable by the class bird in the context of our application? That's the correct question that we should ask ourselves each time we create a relationship between our types. Indeed, incorrect relationships between types cause unexpected bugs or side effects. This can be pretty tricky to spot and correct. And usually correcting them involves a lot of re-factoring and reengineering. To save time and effort, it's important to get them right in the first place, and the Liskov substitution principle will help us to achieve this.

### Detecting Violations of the Liskov Substitution Principle
The Liskov substitution principle is best understood by looking at examples of incorrect type hierarchies. Let's start with a simple one. We have a class called Bird, which has a method, fly, that receives an altitude and performs some flying logic for that particular bird. Then we create the class Ostrich that extends Bird. Ostriches can't fly. Therefore, we have to override the fly method and basically leave an empty implementation. Now, what do you think will happen when we create an ostrich like this? Then we call the fly method with an altitude of 1000. The application won't break, but this method won't produce any results. In other words, the program produces an unexpected result, and the problem comes with this incorrect relationship between the ostrich and the bird. In biology, an ostrich is a bird. But in object-oriented programming and particularly in our program, the class Bird is not fully substitutable by the class Ostrich. We created an incorrect type relationship. Let's look at another example. Each time we harden preconditions, we break the Liskov substitution principle. For example, we have a class called Rectangle with two setters for height and width. Then we have a method called calculateArea, which returns the width multiplied by the height. After that, we create a class Square which extends Rectangle because in mathematical terms, a square is a rectangle. However, in the setters, setHeight and setWidth, we harden the initial preconditions because for a square, the height and the width are equal. So each time we set the height, we also set the width and vice versa. Now in our main program, we create a new Square, we set the width, we set the height, and then we calculate the area. The result will be 400, which, of course, is correct from our program's perspective. However, if you look here at these few lines of code, something doesn't feel right because you created a new Square, the base type is rectangle, so we are able to set the width and height, but we are not expecting the hardened precondition. We're not expecting that when we set the width, the height would also be set, and when we set the height, the width will also be set. So the program behaves in an unexpected way, and that's because we have an incorrect relationship between Square and Rectangle. A rectangle is not fully substitutable by the class Square. And here's where the big problem lies. We saw examples using inheritance. However, we can violate the Liskov substitution principle when we implement interfaces. Take a look at this simple Account interface. It has two methods for processing local transfers and processing international transfers. Then we create a class called SchoolAccount, which implements the Account interface. However, in SchoolAccount, we can only transfer money locally within our country. Therefore, we add business logic there. However we cannot process international transfers, and we throw a RuntimeException to mark that this method is not supported by the SchoolAccount class. When we try to run this program like this, it will crash with an error. Again, this is because we have an incorrect hierarchy between the SchoolAccount class and the Account interface. Basically, an account is not fully substitutable by the SchoolAccount class. Each time you see a method that throws a Not implemented exception, we are violating the Liskov substitution principle. You'll see in the next module that this also violates the interface segregation principle because our class does not fully support the interface it implements. Type checking is another symptom of not adhering to this principle. Imagine that you're working on an Agile board. You have various task types including a BugFix, which is a particular type of task. You want to receive a collection of tasks and set them in progress, and you can do that for all task types except bug fixes. For bug fixes, before you are able to set any progress, you need to initialize the bug description. This kind of approach, where for most subtypes, you do one thing, but for particular subtypes, you do another thing, is an indication that those subtypes cannot substitute their base type. And, again, we are not adhering to the Liskov substitution principle. This example that I've shown over here illustrates the problems and unexpected behavior that may occur when we are not creating correct hierarchies between our types. The Liskov substitution principle can help us to fix them, and we'll see how in the next lecture.

### Fixing Incorrect Relationships between Types
Incorrect relationships between objects are a cause of subtle bugs in our application. Therefore, you need to correct them as soon as you discover them. There are two great ways to refactor code and make it respect the Liskov substitution principle. The first one is to eliminate incorrect relationships between objects. The second one is to use the "Tell, don't ask! " principle to eliminate type checking and typecasting. In the ostrich and bird example, we have a public void fly method that did nothing. This was obviously a violation of the Liskov substitution principle. We can refactor this code by breaking that relationship. Essentially, we'll have two classes, Bird and Ostrich, with their own data and capabilities that are not linked by the inheritance relationship. The Ostrich class no longer has to implement the fly method. We can apply the same principle and break the relationship between square and rectangle. We can fix partially implemented interfaces by breaking the interface down into smaller, more focused pieces. Our SchoolAccount class implements just one method of the Account interface. It does not respect the Liskov substitution principle. However, we can make SchoolAccount implement the LocalAccount interface. This interface exposes a single method, processLocalTransfer. Now our class fully implements the LocalAccount interface. And LocalAccount is fully substitutable by the SchoolAccount class. By splitting the Account interface into smaller interfaces, we've managed to create a correct relationship between SchoolAccount and LocalAccount. We'll talk more about this in the next module where we discussed the interface segregation principle. Type checking can be fixed using a principal called "Tell, don't ask! " Here in this for loop, we are basically asking if t is an instance of a BugFix. Then we're creating a task to transform t from type Task to type BugFix. We initialize the bug description, and then we go on to set the task in progress. We could simplify this and eliminate the type checking altogether by overriding the setInProgress method on the BugFix class. Here we set initializeBugDescription and then set that task in progress. Now our for loop is transformed and looks like this. We are not asking the type of t. Instead, we are telling t to perform the setInProgress action. This is the essence of the "Tell, don't ask! " principle. Here are a couple of proactive ways to apply LSP. Make sure that a derived type can substitute its base type completely. Always ask yourself this question before building a relationship between types. Don't ask the "is a" question. Don't ask yourself, Is square a rectangle? Ask yourself, Does the class Square fully substitute the class Rectangle in all the context of my application? Keep base classes small and focused. If you have a pretty large base class, then breaking the Liskov substitution principle has a higher probability. Big, fat base classes have lots of functionality and methods and make it harder to create elegant and precise inheritance trees. And, last but not least, keep your interfaces lean and focused. Don't implement interfaces that bring more behavior than you would want.

### Demo: Correct Type Hierarchies by Applying the LSP
It's time to apply what we have learned in a demo. We are going to apply the Liskov substitution principle to a component that has an incorrect type relationship. We'll observe the problems of this incorrect type hierarchy and how it affects our program as a whole. And then we will refactor that code using the Liskov substitution principle. The business people came to us to implement subcontractors in the HR framework. A subcontractor is an entity that works similarly to an employee. It has contact information like name and its own email. It has a cost in the form of a monthly income and the number of hours worked in a week. On top of that, subcontractors need to have an approved SLA before working. The SLA dictates what is the resolution time for problems on their projects and the up time for the projects. Because they are external employees, they are not eligible for time off. So after reading these requirements, it's easy to see that a subcontractor is like a kind of employee. We created the class Subcontractor that extends Employee because it makes sense. Subcontractor is like an employee but it has an SLA. However, a subcontractor cannot take time off, so we decided to throw a RuntimeException when this method is called because they're not eligible for time off. And then we have the approveSLA method, which basically checks the SLA against our company's benchmarks and returns true or false. This was the simplest implementation for the Subcontractor class. But was it the best implementation? Is this a good abstraction? Can we substitute subcontractor everywhere we see the employee type? Well, let's find out. Let's look at a couple of processes where subcontractors are involved. The first one is the ApproveSLA flow. We defined the SLA with a minimum time out percent and a maximum resolution time in days for all subcontractors. Then we grab all the employees from our repository, including a couple of subcontractors. And then we want to have their SLAs approved. But only subcontractors have SLAs. So in this for statement here, we need to check if an employee is a subcontractor, and if he is, then we approve the SLA. Now, this doesn't smell very good, but when we go ahead and run this flow, we can see that the application works as expected. So we don't give it too much thought and leave things like this. This is not the only process in our application. Let's look at the NatHolidayEmployeeTimeOff flow. Here, again, we grab all the employees from our repository, and we will want to request one day time off for each employee. If you run this flow over here, we'll get an exception. We'll get a RuntimeException: Not implemented because, if you remember, subcontractors cannot request time off. They're external people who are working for our projects; they are an abstraction. The way that we link a subcontractor with the employee really doesn't work in that particular case. Let's take a look at CalculateEmployeeTaxes. It is the program that we have used in the previous module. We grab the employees and the local currency information. And then for each employee, we calculate the taxes. We'll run this flow again, and, again, we have an exception, an Invalid employee type. And that's because we do not have a tax calculator for a subcontractor. We have calculators for full-time, intern, and part-time employees. Now we could alleviate this problem by creating a subcontractor tax calculator, but that would go against the business requirements because the business requirements dictate that subcontractors should calculate their own taxes. You can see the number of problems and side effects that were introduced when we created this abstraction. Clearly, a subcontractor is not and cannot substitute an employee. Clearly, we need to break that relationship and fix our code by making it adhere to the Liskov substitution principle. Let's break the inheritance relationship between Subcontractor and Employee. I'm going to delete all the contents of this class, and I'm going to replace it with a new implementation. Now Subcontractor is a class that has monthlyIncome, nbHoursPerWeek, email, name, a constructor, and the approvedSLA method. But it has no relationship whatsoever with employees, so we've broken down that relationship. Then we have to come here and modify the ApproveSLA flow. We cannot use the EmployeeRepository anymore because a subcontractor is not an employee. But we can create our own list of employees and treat them separately. Then we just iterate over them and approve their SLA. The other thing that we need to do is we need to correct our old classes. First of all, we cannot add subcontractors in the EmployeeRepository because they are not employees anymore. So I'm just going to delete them from here. And now let's take a look at the old programs, the CalculateEmployeeTaxesMain. This will work as expected now because we no longer have subcontractors coming out of the repository. The same goes for the Time off program. Because we don't mix employees with subcontractors, this flow will also work as it did before. Just by eliminating, just by breaking our inheritance with employee, we have been able to create a subcontractor, create the SLAMain program, and the rest of the application still works as expected. The mistake that we did after reading the specifications was the fact that we did not ask ourselves the correct question. We assumed that the subcontractor is like an employee because it had many similarities with it, so we decided to go for inheritance. We should have asked ourselves, Is an employee fully substitutable by the Subcontractor class? And the answer to that question was, No. The symptoms were there. If we ask ourselves the right questions, then we can apply the Liskov substitution principle proactively. Otherwise, we may have to come back and refactor our code by breaking incorrect relationships.

### Summary
In this module, you saw that the Liskov substitution principle is more subtle than the others. You learned to not think about relationships in terms of "is a. " Always ask yourself if a particular type is substitutable by a particular subtype. Empty methods, type checking, hardened preconditions, and not implemented exceptions are all signs that you are violating the Liskov substitution principle. Pay attention to them and take necessary action when you notice the symptoms in your code. This principle also applies for interfaces, not just class inheritance. It deals with relationships between types in a general matter. And most times, you can fix incorrect type hierarchies by breaking them. We did that with the ostrich/bird example and with the rectangle/square example as well. Real-life categories do not always map to OOP relationships. That's why we need the Liskov substitution principle to help us create correct hierarchies between objects. I would like to end this module with a funny quote from a SOLID motivational poster. "If it looks like a duck, quacks like a duck, but needs batteries, you probably have the wrong abstraction. " The Liskov substitution principle helps us to create correct hierarchies between types, which guarantee that your program will run correctly and without any undesired side effects.
