# Modularizing Abstractions with the Interface Segregation Principle (ISP)
The Interface Segregation Principle
Hello again. In this module, you are going to learn how to find the perfect granularity level for your abstractions by using the interface segregation principle. We'll start by looking at a definition for the interface segregation principle. Then you'll learn to identify "fat" interfaces and the symptoms that they leave in our codebase. After that we're going to see how to refactor code that depends on large interfaces. Once you have this technique mastered, we can move on to a demo in which we'll apply the interface segregation principle to fix clients that depend on large interfaces. The interface segregation principle has a pretty simple definition. Clients should not be forced to depend on methods that they do not use. We have to split interfaces that are very large into smaller, more focused interfaces so that clients that use them will not be forced to depend on things that they do not need. In the interface segregation principle, the word "interface" does not necessarily mean a Java interface. Most of the time, this is the case. However, the interface segregation principle also applies for abstract classes or, in fact, any public method that our own class depends upon. The nice thing about the interface segregation principle is that it reinforces other SOLID principles. For example, if we keep interfaces small, the classes that implement them have a higher chance to fully substitute that interface. This is the Liskov substitution principle that we've talked about in the previous module. By applying the interface segregation principle, we are reinforcing the Liskov substitution principle. If we have large interfaces with many methods, then there's a great chance that the derived types will not fully support all those methods. Thus, they will not be fully substitutable for the base interface. Therefore, they will violate the Liskov substitution principle. Also, classes that implement small interfaces are more focused and tend to have a single purpose. So we reinforce the single responsibility principle. If you create a very large interface with many methods, then the class that implements it needs to provide a behavior for all of those methods. Therefore, it might violate the single responsibility principle and do more things than it should. These two principles also reinforce one another. Before we go on, let's look at the many benefits of applying the interface segregation principle. First of all, lean interfaces minimize dependencies on unused members and reduce code coupling. Code coupling is the number one enemy of clean code. Code coupling leads to technical debt. And technical debt is not good as you saw in the beginning of this course. Then, code becomes more cohesive and more focused, which is also a good thing. And, last but not least, this principle reinforces the use of the single responsibility principle and Liskov substitution principle. At this point, you might think that the interface segregation principle is the simplest of them all. I hope I've convinced you that the implications are deeper than they appear at first sight. By keeping interfaces small, we end up with a more decoupled system that is easier to change, maintain, and evolve over time.

Identifying “Fat” Interfaces
Before we apply the interface segregation principle, the first thing that we need to master is to identify "fat" or large interfaces. There are a couple of symptoms that manifest themselves and that tell you precisely when an interface should be re-factored and made smaller. The first case that I want to present is interfaces with many methods. Let's take a look at the LoginService interface. We have several methods over here, and the list would go on--signIn, signOut, getUserDetails, setSessionExpiration, validateToken. Each time you see an interface that has a lot of methods, it might be a good indicator that you might need to break it down into smaller interfaces. And let's take a look at a problem. Let's say we want to create a class called GoogleLoginService. We want to implement the LoginService interface. However, because the authentication is handled by Google, we might need to implement just signIn and signOut. Methods like updateRememberMeCookie or setSessionExpiration are not valid in the context of a Google authentication. Therefore, we throw an UnsupportedOperationException and not implement them. This is a problem because the GoogleLoginService class violates the interface segregation principle and also the Liskov substitution principle. So pay attention when you have large interfaces. They might force you to create classes that do not fully support them. Another example is interfaces with low cohesion. Cohesion refers to the purpose of a particular component. When all the methods are aligned with the overall purpose of that component, then we say that those methods are cohesive. Another example, we can have an interface called ShoppingCart. ProcessPayment and checkItemInStock do not conceptually belong to a shopping cart. They probably belong to a payment processor or a stock verify service. So, again, this interface and the methods within it are not cohesive. We don't have unnecessarily a lot of methods. Just four methods is not a large number. But the methods are not cohesive with the overall purpose of the interface. And when we try to implement it, we create a class called ShoppingCartImpl, and we are forced to implement those two methods. And for processPayment, for example, we're not going to throw an exception. We're actually going to implement it, so we need to bring in a lot of dependencies. We need a PaymentService. We need the UserService. We need the EmailService. So we've effectively increased coupling a lot because we are forced to provide an implementation for the processPayment method when all we wanted was a ShoppingCartImpl. Although this class does not violate the interface segregation principle because it fully implements that interface, it does, however, violate the single responsibility principle because now the ShoppingCart has more responsibilities than it has to. Cohesion was also affected because ShoppingCart is now responsible for doing other things besides its main focus, keeping track of the items added to the basket. Like I said before, the interface segregation principle is not only about interfaces. We can have the same problems with abstract classes. Take a look at the Account class. We have three methods, getBalance for our account, processLocalPayment, and processInternationalPayment. Then we try to extend this abstract class. We have a new component called SchoolAccount, which extends Account. SchoolAccount, on the other hand, does not allow international payments, so when we override this method, we have to provide the behavior. And in this case, we're not going to throw an exception; we're not going to implement it. We're going to do nothing because we think it's better than throwing an error. Well, it's not. Again, this is a symptom that we have violated the interface segregation principle because we are taking on methods that we don't actually need. These are the most common symptoms that you'll see when dealing with fat interfaces and violations of the interface segregation principle. Let's take another look at them. Interfaces with lots of methods should definitely be a warning sign. Interfaces with low cohesion where the methods do not adhere to the overall goal of your component should also be a warning sign that should tell you you're dealing with an interface that is not properly structured, is not granular enough. Clients that throw exceptions instead of implementing methods provide a clear symptom of interface pollution. Clients that provide empty implementations are another example. And, last but not least, when a client forces implementation and becomes highly coupled, again, it's more subtle, but it's a good indicator that you're taking on more features than you need.

Refactoring Code That Depends on Large Interfaces
Now that you know the symptoms of interface pollution, let's see what we can do to refactor code that depends on large interfaces. If you own the code, breaking interfaces is pretty easy and safe due to the possibility to implement as many interfaces as you want. Instead of having one interface with three methods, we can have three interfaces each with one method. And then the class can implement all of them to achieve the same result. So that's pretty straightforward and pretty safe. On the other hand, if you're working with external legacy code and you don't control the interfaces that you have to implement, then you cannot break them down. So you need something else. Design patterns can help you with this. The adapter pattern is particularly useful for dealing with this kind of situation because it translates, it adapts interfaces that you can't control to another interface that you can use in your own code. I want to focus on the first technique. I'll assume that we own the code. Let's see how we can refactor large interfaces and make them respect the interface segregation principle. Let's take a look at the Account interface. It has three methods, getBalance, processLocalPayment, and processInternationalPayment. As we saw in a previous example, when we try to implement various variations of Account, it doesn't necessarily work. SchoolAccount, for example, doesn't support international payments, so we are forced to either throw an exception or leave that method empty, which, of course, violates this principle. What we could do is split this interface into three lean interfaces. We can create a BaseAccount interface that exposes the getBalance method. And then we can have a LocalMoneyTransferCapability, which enables clients to process local payments. And after that, we can have an IntlMoneyTransferCapability, which enables clients to process international payments. We have more granularity in building our clients. For example, the SchoolAccount class can implement Account and LocalMoneyTransferCapability. We are no longer forced to provide an implementation for the IntlMoneyTransferCapability. Our class only overrides the methods it needs. This also leads to interface reuse. Let's assume that we need to create a class called InternationalLoanService. The loan service is not an account. It just exposes IntlMoneyTransferCapability. So we simply implement that interface and override that method. We are now using those lean interfaces in ways that we didn't think about when we first created them, and that's the good thing about having small interfaces. We can compose and reuse them however we see fit during the evolution of our product. This technique of breaking interfaces down is pretty simple. So respecting the interface segregation principle once you know the symptoms is pretty straightforward.

Demo: Breaking down Large Interfaces Using the Interface Segregation Principle
Let's look at the interface segregation principle in practice. More precisely, we'll refactor code that uses fat interfaces and make it adhere to this principle. We'll observe the symptoms of inappropriate large interfaces. And then we'll modularize the interfaces and refactor the code using the interface segregation principle. We have a new requirement from the business analysts. We need to implement a new document called the payslip. The payslip should contain the month of income, the name of the employee, and the income of the employee for the given month. The payslip should also be an exportable document. At this stage, we are interested to export it as text, but it might be possible to extend this to other formats. As developers, after reading the specification, we go scan the code, and we come across the ExportableDocument interface. The ExportableDocument interface has three methods, toPdf, toJson, and toTxt. So because we want to export our payslip to text and in the future it might be possible to export it to other formats as well, we decide to go ahead and create our Payslip class. Let's take a look at it. We made a Payslip class that implements the ExportableDocument interface. We implemented the few properties that were required of us along with a constructor, getters, and then we went ahead to implement the ExportableDocument interface. We are interested in exporting this document text. So we provide an appropriate implementation. However, for the time being, we have no implementation for PDF and JSON format. So we go ahead and just throw an UnsupportedOperationException. We have this program that exports the payslips for all employees. We iterate over the collection of employees. We generated the payslip for each employee and for a given month. Then we get the exportableText, and we print the text to the console. This program works, but clients of our HR framework are not aware that we just implemented a couple of the methods from the ExportableDocument class. Because those methods are publicly available on payslip, they can simply call those in their programs. They might want to export a payslip to PDF. There's nothing stopping them to call the toPdf method on the Payslip class. When we try to run this program, it will obviously fail because the toPdf method is not implemented. And the program will crash with an UnsupportedOperationException. These are the kinds of problems that you might expect when dealing with large interfaces. If you want to avoid these kinds of problems in the future, we clearly need to refactor the Payslip class. And the interface segregation principle can help us to achieve this. We are going to break the ExportableDocument interface into smaller interfaces and then just use the pieces of functionality that we are interested in. I have created three new interfaces, ExportableJson, ExportablePdf, and ExportableText. The ExportableJson interface exposes the toJson method. ExportablePdf exposes the toPdf method, and ExportableText exposes the toTxt method. We can replace ExportableDocument with the format that we are interested in. In our case, it's ExportableText. In the future when we'll have to provide other formats as well, we can simply add in more interfaces for all the formats. I'm going to go ahead and delete these two methods because we do not need them anymore. Our ExportPayslip program will also work as expected, and here we can see that the Payslip class only exports the toTxt method. ToPdf and toJson are no longer available. And this is a good thing. But what happens to existing classes? For example, the WorkContract class also implemented the ExportableDocument interface. And it provided implementations for all of these formats. We can simply replace the ExportableDocument interface with the three interfaces that we just created, ExportableJson, ExportableText, and ExportablePdf. The program will also work as expected, and it will compile and run correctly. That is the great thing about splitting interfaces into more manageable pieces, we can simply implement as many as we need, and we won't break functionality in existing code. To finish our re-factoring, we need to delete the ExportableDocument interface because we no longer need it. I'm going to go ahead and delete it, and our program will still work as expected. The bottom line for this demo is that most of the time, less is more. We started out with good intentions. We wanted to reuse an existing interface. However, by doing that, we have violated the interface segregation principle. We forced future clients to implement methods that they did not need, and this choice will always lead to undesired side effects and more coupling. That's why it's always better to have smaller interfaces that are easier to compose and use.

Summary
In this module, we took a closer look at the interface segregation principle. You saw that the ISP is closely linked with the Liskov substitution principle and the single responsibility principle. When we have large interfaces, we pose a lot of difficulties on the clients that need to implement them. Those clients can end up with more responsibilities than they should, thus violating the single responsibility principle, or may not be able to fully support the interfaces that they implement, and thus they will violate the Liskov substitution principle. Don't confuse the word "interface" in the name of this principle with an actual Java interface. Most of the time, this is the case. However, you saw that you can break the interface segregation principle by extending abstract classes or classes. Pay attention to the symptoms of large interfaces. Each time an interface has a lot of methods, when cohesion is low, when you have clients that don't implement particular methods or that become highly coupled because they're obliged to implement all of them, you need to take action. You can break large interfaces into many small and focused ones for code that you own. For code that you don't own, you can use the adapter pattern. Fat interfaces lead to inadvertent couplings between clients that ought otherwise to be isolated. Therefore, it's better to have many client-specific interfaces than one general purpose interface. And I think that's the key takeaway from the interface segregation principle.
