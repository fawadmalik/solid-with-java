# Evolving Code with the Open Closed Principle (OCP)

The Open Closed Principle
In this module, we'll discuss about the open closed principle and how it can help us to write code that is easy to change and evolve over time. We'll start by defining the open closed principle and seeing why it is a good idea to apply it when implementing changes. Then we'll go to a demo in which we'll see how we can implement the new feature without the OCP. We'll find out why this is not such a good idea. Then we'll look at some concrete OCP implementation strategies. We'll apply these strategies in a new demo in which we will implement the C feature but this time using using the open closed principle. You will then have a pretty good idea of why you should use this principle because you can compare it to the previous demo. And we'll wrap it up with a quick discussion about how to apply the open closed principle for frameworks in API design. The open closed principle states that classes, functions, and modules should be closed for modification but open for extension. But what does closed for modification and open for extension really mean? Well, a class is closed for modification if for each feature that we need to add, we do not touch an existing source code. The source code basically becomes immutable. At the same time, a component is open for extension if it allows us to make it behave in new ways by creating or writing new code. And the open closed principle tries to re-conciliate these two mantras. Let's take a look at a conceptual example and see why modifying existing code is not such a good idea. Assume that we have a system with three classes, Classes A, B, and C. We want to implement a new feature, and we go ahead and do that by modifying code in Class A. Do notice that Classes B and C depend upon Class A. When we modified Class A by mistake, we also broke Class B because Class B was dependent on it. That's the main problem with modifying existing source code. There is a high risk of breaking other components, and this is just a very simple example. In a real application, the dependency graph is much more complex, and changes to particular components can have ripple effects in various parts of the system. Again, this is fragility. A better approach would have been to implement that change and put it in a new component. Let's call it Class D. If we do this, then we implement our feature, but we do not touch the existing system. Therefore, we have a very low risk of introducing regression bugs. You are probably starting to guess why this principle is so important, first of all, because new features can be added easily and with minimal cost. Even in legacy applications that are very tangled and old and complex, each time we need to make a change, the best way is to put that change in a separate component, write a unit test for it, and that's it. If we go ahead and start to touch old components, legacy components, then that risk that I was telling you about is very, very high. So we can use the open closed principle in every application. Then the open closed principle minimizes the risk of regression bugs. And, finally, it enforces decoupling by isolating changes in specific components because every time you need to make an important change, you put it in its own place. You can see how the open closed principle kind of works together with the single responsibility principle. And I think that's the essence of the SOLID principles because they are most effective when they are applied together.

Demo: Downside of Adding Features by Modifying Existing Code
Understanding the dangers of modifying existing code is more evident in a real example. In this demo, we are going to add a new software feature to our HR framework without applying the open closed principle. We'll have a chance to observe how easy it is to violate it and also the problems that modifying existing code has on your software design. We'll continue to work on the Globomantics HR framework. In the Business Requirement Document, we have specifications for implementing a tax calculator. For each employee, the taxes consist of three parts, a fixed $100 amount for the base health insurance, 16% income tax, and 10% retirement tax. After reading these requirements, the initial TaxCalculator component was created. Pretty simple, we define the constants that represent the tax percentages, and then we have a calculate method which implements the specifications described in the document. Later on we add new requirements. The business guys came to us and told us that now tax calculations should be based on the type of employee. For full-time employees, the calculation remains the same. For part-time employees, we have just a 5% retirement tax instead of 10%. And for interns based on the value of their income, either no tax or just a 16% income tax. We want to implement these new requirements, and we'll do that by taking the shortest route, meaning we'll modify the existing calculate method in the TaxCalculator class to handle all the scenarios described in the Business Requirement Document. I'm going to delete the current implementation. This is what our new implementation looks like. When the employee is a FullTimeEmployee, we keep the current implementation. When the employee is a PartTimeEmployee, we apply a smaller retirement tax. And for the Interns, if they have a monthly income less than $350, there is no tax. Otherwise, just apply the income tax. You can observe how the implementation of this method has grown in complexity. It's a lot harder to follow what this method does precisely. The bad news is that if we want to add more types of employees in the future, we need to come here and modify this method as well. So this method has everything you need to become a new master method. Not only is this not a good thing, it also introduces useless risk because the TaxCalculator is used throughout our system. We need to find a different way to add these new features without constantly changing existing code.

Open Closed Principle Implementation Strategies
You saw that modifying existing code is not the best approach when dealing with areas of an application that are very susceptible to change. Luckily for us, there is a better way to implement changes without modifying existing code, and that is by extending its capabilities. There are two great ways to do that. The first one is inheritance, and the other one is a design pattern called the strategy pattern. Take a look at this simple class. It's called BankAccount, and it exposes a feature for transferring money internally in the same country. And now we have a new request to also handle international transfers. Now the worst approach to this would be to start modifying the existing transferMoney method and put the logic for the international transfer here as well. We are not going to do that. Instead, we are going to extend the capabilities of this class. The easiest way to do that is by using inheritance. We can simply create a new class called InternationalBankAccount, which extends the BankAccount class and simply overrides the transferMoney method with business logic for international transfer. We are basically creating a new component that can handle international money transfers, but we're not touching the original BankAccount class. Inheritance is a good way to apply the open closed principle. It does, however, have a small drawback. Inheritance produces coupling between the derived classes and the base class, especially when we are using a concrete class as the base class. This is the case here. We are extending BankAccount, which is a concrete class, and inadvertently we're introducing a form of coupling. A better approach to applying the open closed principle is a design pattern called the strategy pattern. In the strategy pattern, we are not using inheritance, but we are using interfaces. So instead of creating new classes for each bank account transfer type, we are extracting that functionality into an interface. We create a new interface called MoneyTransferProc, and we declare this capability, this transferMoney capability. Then we can create classes that implement this interface. In our case, we have two classes, BankAccount and IntlBankAccount, which implement the MoneyTransferProc, and each of them can provide their own implementation for this method. However, BankAccount and IntlBankAccount are not linked in any other way. IntlBankAccount does not inherent from BankAccount. This means that these two classes can evolve independently. They have no coupling with each other. After we have our strategies, we need the factory that is capable to build them based on a particular property, like a TransferType. So we create a MoneyTransferProcessorFactory, which has one method called build. A build method receives a TransferType. It can be international, local, whatever, and it gives us back an instance of a particular MoneyTransferProc. If the TransferType is local, we have the BankAccount class. Else, we have the IntlBankAccount class. Then when we are processing payments, we can just have a generic method that takes the amount and the TransferType. The factory is going to give us a concrete instance of a particular MoneyTransferProc, and then we'll call the transferMoney method on that processor. The beauty of this is that every time we need to add new transfer capabilities, we do not need to modify this class. Nor do we need to modify existing strategies like BankAccount or IntlBankAccount. All we have to do is create a new component, implement the MoneyTransferProc interface, and provide that concrete implementation. So, which one should you choose? I propose that you take a progressive approach when applying the open closed principle. Start small in the beginning. You don't have to create new components to implement changes for the first time. Instead, make those changes inline, and then if there is a real need, extract them to different components. Also, don't apply the open closed principle for bug fixing. If you have a broken component, you should change that component and make it work as expected. If you have areas of your code that are likely to change over time, then you should probably consider one of the two alternatives for applying the OCP. Start with inheritance. If that does the trick, fine. If you need something more powerful or more flexible, then you should consider design patterns like strategy.

Demo: Extend Software Capabilities Using the Open Closed Principle
Let's put this information to use and apply the open closed principle to the tax calculation requirements. We are going to add a new software feature using the open closed principle. We get the chance to apply the strategy pattern and see how it can be used to implement new capabilities without modifying existing code. Our new business requirements tell us that tax calculation should be done based on the employee type. In the previous demo, we tried to put all this implementation in the TaxCalculator, but that wasn't the best approach. Let's try to apply the strategy pattern and see how we can add new features without modifying existing code. The existing TaxCalculator class just handles calculations for the full-time employee. So instead of changing it, I'm just going to rename it to FullTimeTaxCalculator. Now this class has a clear and specific purpose. The next thing that I want to do is I want to extract an interface for the calculate method. I'm going to call this interface TaxCalculator. And, of course, it's going to have a simple method that will calculate taxes. I'm going to go back to the FullTimeTaxCalculator, and I'm going to make it implement the TaxCalculate interface that I've just created. We are now in a good spot to begin applying calculations for the part-time employee and the intern without having to touch this existing class. Then notice that although we have renamed it and made it implement the new interface, we did not touch the method implementation nor the internal specifications of this class. Let's go ahead and create two new classes for part-time tax calculations and employee tax calculations. I just created two new classes that implement the TaxCalculator interface, InternTaxCalculator and PartTimeTaxCalculator. We are going to use these classes to implement specific tax calculations for these employee types. Let's implement the PartTimeTaxCalculator first. I'm going to delete this _____ implementation, and I'm going to replace it with the correct one. This is what the PartTimeTaxCalculator should look like. It overrides the calculate method and provides the implementation with the correct RETIREMENT_TAX_PERCENTAGE. We'll do the same thing for the InternTaxCalculator. And there it is. The InternTaxCalculator now adheres to the internal documentation. If the monthlyIncome is less than $350, then there is no tax. Otherwise, we just apply the income tax percentage. One thing that I want to point out is that these three classes, the FullTime, Intern, and PartTimeTaxCalculators, are now very specific. They just calculate one thing, a tax for a particular type of employee. By implementing new functionality using the open closed principle, we have indirectly also applied the single responsibility principle. This is how SOLID principles work well together and reinforce one another. Now that we have three implementations, I want to create the factory that can service a concrete instance of a tax calculator based on the employee type. And this is what our factory looks like. We receive an employee as a parameter, and based on the employee type, we either return a FullTimeTaxCalculator, a PartTimeTaxCalculator, or an InternTaxCalculator. Now that we have the plumbing in place, let's go to the main method and see what changes need to be done over there. The CalculateTaxesMain class is the entry point that executes a tax calculation against all employees. We iterate over our collection of employees. We calculate the taxes. And then we format them, print them, and then add them to the company total taxes. That is the essence of this main class. However, after we've made our changes, there are some things that no longer work. First of all, the TaxCalculator instantiation can no longer work because TaxCalculator is now an interface. So we have to remove this piece of code from here. Then the TaxCalculator is created based on the employee type. So here in the for loop, we need to instantiate it using the Factory class that we just created. We pass in an employee, and then the Factory will give us a concrete instance of the TaxCalculator based on that type. Then the program works as expected. So with minimal changes, we managed to re-implement our features using the open closed principle. Let's run our application and see that it works as expected. And here are our tax calculations for each employee in our EmployeeRepository. The application works as expected. The beauty of this code is that if new employee types are to be added, we do not need to modify the main method, nor do we need to modify any of the tax calculators that we just created. We only have to create a new class that implements the TaxCalculator method and then provide the particular implementation. And that's it. The rest of the code will still work, and we won't have to touch existing code. That's the beauty of the open closed principle.

Applying the Open Closed Principle for Frameworks and APIs
I want to take a couple of minutes to discuss a more subtle version of the open closed principle, and that is its relation to framework and API design. An API is a contract or agreement between different software components on how they should work together. JUnit, for example, is a popular testing framework. A key point here is that a public framework or API is completely under your control. Clients cannot change existing code. However, the changes that you make to that framework can impact clients because they might use it in ways that you aren't aware of. So it's important to know how to apply the open closed principle when designing frameworks or SDKs. Let's take a simple example. We are creating an HR framework, and we have a TaxCalculator that _____ an employee and calculates some taxes. You package your SDK into a JAR file, you put it on Maven, and then your clients can use it in their own applications. However, later on, you decide that you want to also include currency in the TaxCalculator, and you do that by violating the open closed principle. You basically modify the existing TaxCalculator, and you add the new parameter to the calculate method. Although your code might work, when your clients get the updated version of this framework, their code will break. Changing existing functionality in publicly exposed frameworks can have devastating effects on the consumers. How can we apply the open closed principle in this scenario? You can make your library open for extension. For example, we could extract an interface called AbstractTaxCalculator. Then in our framework, we provide some implementations from default implementations for it. And when the customers are not satisfied with the default implementations, they can just create a new class, implement the AbstractTaxCalculator that you created, and provide their own logic. This is what an extensible framework looks like. You provide your clients with interfaces that can act like extension points where they can hook up their custom logic with your framework. Here are some best practices for changing APIs. First of all, do not change existing public contracts like data classes or method signatures. Then, be sure to expose abstractions to your customers and let them add new features on top of your framework. When you expose abstract classes or interfaces, you're basically providing an extension point for your clients to provide their own custom logic and fill in the gaps of your framework. And, last but not least, if you really need to do a breaking change, give your clients time to adapt. Don't just change your API overnight without letting them know. Instead, create the new methods or the new functionality, mark the old one as deprecated, and let them know that in a particular month of time, the code that they might be using will be removed.

### Summary
In this module, we tried to look at the open closed principle from many angles. Changing requirements are inevitable in real-life applications. And the open closed principle provides an elegant way to extend functionality without modifying existing code. Modifying existing code is risky because it can incur breaking changes on other components. You saw how inheritance and design patterns are effective ways to add features without modifying existing code. OCP also applies to packages, not just to classes and methods. Each time you design a package or a framework, be sure to not break existing data contracts and also leave extension points in the form of interfaces or abstract classes that can be used to extend the package capabilities. Sometimes it is really not pragmatic to extend a component, and you really need to modify it. Bug fixing is a good example. When you're fixing bugs, it's okay to modify existing code. Also, for small changes or areas that will not evolve over time, it's okay to modify existing code. Don't go overboard with the open closed principle. Use it only when needed. Also, be aware that making a flexible design adds more complexity to your application. That's why it's important to start small and abstract later when needed. The open closed principle is all about changes. Following it will lead to elegant designs that are easy and painless to extend in the future.
